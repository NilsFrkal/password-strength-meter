{"ast":null,"code":"export class TimeEstimates {\n  static estimate_attack_times(guesses) {\n    const crack_times_seconds = {\n      online_throttling_100_per_hour: guesses / (100 / 3600),\n      online_no_throttling_10_per_second: guesses / 10,\n      offline_slow_hashing_1e4_per_second: guesses / 1e4,\n      offline_fast_hashing_1e10_per_second: guesses / 1e10\n    };\n    const crack_times_display = {};\n\n    for (let scenario in crack_times_seconds) {\n      const seconds = crack_times_seconds[scenario];\n      crack_times_display[scenario] = this.display_time(seconds);\n    }\n\n    return {\n      crack_times_seconds,\n      crack_times_display,\n      score: this.guesses_to_score(guesses)\n    };\n  }\n\n  static guesses_to_score(guesses) {\n    const DELTA = 5;\n\n    if (guesses < 1e3 + DELTA) {\n      // risky password: \"too guessable\"\n      return 0;\n    } else if (guesses < 1e6 + DELTA) {\n      // modest protection from throttled online attacks: \"very guessable\"\n      return 1;\n    } else if (guesses < 1e8 + DELTA) {\n      // modest protection from unthrottled online attacks: \"somewhat guessable\"\n      return 2;\n    } else if (guesses < 1e10 + DELTA) {\n      // modest protection from offline attacks: \"safely unguessable\"\n      // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n      return 3;\n    } else {\n      // strong protection from offline attacks under same scenario: \"very unguessable\"\n      return 4;\n    }\n  }\n\n  static display_time(seconds) {\n    const minute = 60;\n    const hour = minute * 60;\n    const day = hour * 24;\n    const month = day * 31;\n    const year = month * 12;\n    const century = year * 100;\n    let [display_num, display_str] = Array.from((() => {\n      let base;\n\n      if (seconds < 1) {\n        return [null, 'less than a second'];\n      } else if (seconds < minute) {\n        base = Math.round(seconds);\n        return [base, `${base} second`];\n      } else if (seconds < hour) {\n        base = Math.round(seconds / minute);\n        return [base, `${base} minute`];\n      } else if (seconds < day) {\n        base = Math.round(seconds / hour);\n        return [base, `${base} hour`];\n      } else if (seconds < month) {\n        base = Math.round(seconds / day);\n        return [base, `${base} day`];\n      } else if (seconds < year) {\n        base = Math.round(seconds / month);\n        return [base, `${base} month`];\n      } else if (seconds < century) {\n        base = Math.round(seconds / year);\n        return [base, `${base} year`];\n      } else {\n        return [null, 'centuries'];\n      }\n    })());\n\n    if (display_num != null && display_num !== 1) {\n      display_str += 's';\n    }\n\n    return display_str;\n  }\n\n} //# sourceMappingURL=time_estimates.js.map","map":null,"metadata":{},"sourceType":"module"}