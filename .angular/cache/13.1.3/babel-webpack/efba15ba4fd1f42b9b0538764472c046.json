{"ast":null,"code":"let name;\nimport { frequency_lists } from './frequency_lists';\nimport { adjacency_graphs } from './adjacency_graphs';\nimport { build_graph } from './generate_adjacency_graph';\nimport { Scoring } from './scoring';\n\nconst build_ranked_dict = function (ordered_list) {\n  const result = {};\n  let i = 1; // rank starts at 1, not 0\n\n  for (let word of Array.from(ordered_list)) {\n    result[word] = i;\n    i += 1;\n  }\n\n  return result;\n};\n\nconst RANKED_DICTIONARIES = {};\n\nfor (name in frequency_lists) {\n  const lst = frequency_lists[name];\n  RANKED_DICTIONARIES[name] = build_ranked_dict(lst);\n}\n\nconst GRAPHS = {\n  qwerty: adjacency_graphs.qwerty,\n  dvorak: adjacency_graphs.dvorak,\n  keypad: adjacency_graphs.keypad,\n  mac_keypad: adjacency_graphs.mac_keypad\n};\nconst L33T_TABLE = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  e: ['3'],\n  g: ['6', '9'],\n  i: ['1', '!', '|'],\n  l: ['1', '|', '7'],\n  o: ['0'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  x: ['%'],\n  z: ['2']\n};\nconst REGEXEN = {\n  recent_year: /19\\d\\d|200\\d|201\\d/g\n};\nconst DATE_MAX_YEAR = 2050;\nconst DATE_MIN_YEAR = 1000;\nconst DATE_SPLITS = {\n  4: [[1, 2], [2, 3] // 91 1 1\n  ],\n  5: [[1, 3], [2, 3] // 11 1 91\n  ],\n  6: [[1, 2], [2, 4], [4, 5] // 1991 1 1\n  ],\n  7: [[1, 3], [2, 3], [4, 5], [4, 6] // 1991 11 1\n  ],\n  8: [[2, 4], [4, 6] // 1991 11 11\n  ]\n};\nexport let Matching = /*#__PURE__*/(() => {\n  class Matching {\n    static empty(obj) {\n      return (() => {\n        const result = [];\n\n        for (let k in obj) {\n          result.push(k);\n        }\n\n        return result;\n      })().length === 0;\n    }\n\n    static extend(lst, lst2) {\n      return lst.push.apply(lst, lst2);\n    }\n\n    static translate(string, chr_map) {\n      return Array.from(string.split('')).map(chr => chr_map[chr] || chr).join('');\n    }\n\n    static mod(n, m) {\n      return (n % m + m) % m;\n    } // mod impl that works for negative numbers\n\n\n    static sorted(matches) {\n      // sort on i primary, j secondary\n      return matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j);\n    } // ------------------------------------------------------------------------------\n    // omnimatch -- combine everything ----------------------------------------------\n    // ------------------------------------------------------------------------------\n\n\n    static omnimatch(password, options) {\n      const matches = [];\n      const matchers = [this.dictionary_match, this.reverse_dictionary_match, this.l33t_match, this.spatial_match, this.repeat_match, this.sequence_match, this.regex_match, this.date_match];\n\n      for (let matcher of Array.from(matchers)) {\n        this.extend(matches, matcher.call(this, password, options === null || options === void 0 ? void 0 : options.keyboard_layouts));\n      }\n\n      return this.sorted(matches);\n    } //-------------------------------------------------------------------------------\n    // dictionary match (common passwords, english, last names, etc) ----------------\n    //-------------------------------------------------------------------------------\n\n\n    static dictionary_match(password, _ranked_dictionaries = RANKED_DICTIONARIES) {\n      const matches = [];\n      const len = password.length;\n      const password_lower = password.toLowerCase();\n\n      for (let dictionary_name in _ranked_dictionaries) {\n        const ranked_dict = _ranked_dictionaries[dictionary_name];\n\n        for (let i = 0, end = len, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n          for (let j = i, end1 = len, asc1 = i <= end1; asc1 ? j < end1 : j > end1; asc1 ? j++ : j--) {\n            if (password_lower.slice(i, +j + 1 || undefined) in ranked_dict) {\n              const word = password_lower.slice(i, +j + 1 || undefined);\n              const rank = ranked_dict[word];\n              matches.push({\n                pattern: 'dictionary',\n                i,\n                j,\n                token: password.slice(i, +j + 1 || undefined),\n                matched_word: word,\n                rank,\n                dictionary_name,\n                reversed: false,\n                l33t: false\n              });\n            }\n          }\n        }\n      }\n\n      return this.sorted(matches);\n    }\n\n    static reverse_dictionary_match(password, _ranked_dictionaries) {\n      if (_ranked_dictionaries == null) {\n        _ranked_dictionaries = RANKED_DICTIONARIES;\n      }\n\n      const reversed_password = password.split('').reverse().join('');\n      const matches = this.dictionary_match(reversed_password, _ranked_dictionaries);\n\n      for (let match of Array.from(matches)) {\n        match.token = match.token.split('').reverse().join(''); // reverse back\n\n        match.reversed = true; // map coordinates back to original string\n\n        [match.i, match.j] = Array.from([password.length - 1 - match.j, password.length - 1 - match.i]);\n      }\n\n      return this.sorted(matches);\n    }\n\n    static set_user_input_dictionary(ordered_list) {\n      return RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict(ordered_list.slice());\n    } //-------------------------------------------------------------------------------\n    // dictionary match with common l33t substitutions ------------------------------\n    //-------------------------------------------------------------------------------\n    // makes a pruned copy of l33t_table that only includes password's possible substitutions\n\n\n    static relevant_l33t_subtable(password, table) {\n      const password_chars = {};\n\n      for (let chr of Array.from(password.split(''))) {\n        password_chars[chr] = true;\n      }\n\n      const subtable = {};\n\n      for (let letter in table) {\n        const subs = table[letter];\n        const relevant_subs = Array.from(subs).filter(sub => sub in password_chars);\n\n        if (relevant_subs.length > 0) {\n          subtable[letter] = relevant_subs;\n        }\n      }\n\n      return subtable;\n    } // returns the list of possible 1337 replacement dictionaries for a given password\n\n\n    static enumerate_l33t_subs(table) {\n      let k;\n\n      const keys = (() => {\n        const result = [];\n\n        for (k in table) {\n          result.push(k);\n        }\n\n        return result;\n      })();\n\n      let subs = [[]];\n\n      const dedup = function (subs) {\n        let v, k;\n        const deduped = [];\n        const members = {};\n\n        for (var sub of Array.from(subs)) {\n          var assoc = (() => {\n            const result1 = [];\n\n            for (v = 0; v < sub.length; v++) {\n              k = sub[v];\n              result1.push([k, v]);\n            }\n\n            return result1;\n          })();\n\n          assoc.sort();\n\n          const label = (() => {\n            const result2 = [];\n\n            for (v = 0; v < assoc.length; v++) {\n              k = assoc[v];\n              result2.push(k + ',' + v);\n            }\n\n            return result2;\n          })().join('-');\n\n          if (!(label in members)) {\n            members[label] = true;\n            deduped.push(sub);\n          }\n        }\n\n        return deduped;\n      };\n\n      var helper = function (keys) {\n        if (!keys.length) {\n          return;\n        }\n\n        const first_key = keys[0];\n        const rest_keys = keys.slice(1);\n        const next_subs = [];\n\n        for (let l33t_chr of Array.from(table[first_key])) {\n          for (let sub of Array.from(subs)) {\n            let dup_l33t_index = -1;\n\n            for (let i = 0, end = sub.length, asc = 0 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n              if (sub[i][0] === l33t_chr) {\n                dup_l33t_index = i;\n                break;\n              }\n            }\n\n            if (dup_l33t_index === -1) {\n              const sub_extension = sub.concat([[l33t_chr, first_key]]);\n              next_subs.push(sub_extension);\n            } else {\n              const sub_alternative = sub.slice(0);\n              sub_alternative.splice(dup_l33t_index, 1);\n              sub_alternative.push([l33t_chr, first_key]);\n              next_subs.push(sub);\n              next_subs.push(sub_alternative);\n            }\n          }\n        }\n\n        subs = dedup(next_subs);\n        return helper(rest_keys);\n      };\n\n      helper(keys);\n      const sub_dicts = []; // convert from assoc lists to dicts\n\n      for (let sub of Array.from(subs)) {\n        const sub_dict = {};\n\n        for (let [l33t_chr, chr] of Array.from(sub)) {\n          sub_dict[l33t_chr] = chr;\n        }\n\n        sub_dicts.push(sub_dict);\n      }\n\n      return sub_dicts;\n    }\n\n    static l33t_match(password, _ranked_dictionaries = RANKED_DICTIONARIES, _l33t_table = L33T_TABLE) {\n      let token;\n      const matches = [];\n\n      for (let sub of Array.from(this.enumerate_l33t_subs(this.relevant_l33t_subtable(password, _l33t_table)))) {\n        if (this.empty(sub)) {\n          break;\n        } // corner case: password has no relevant subs.\n\n\n        const subbed_password = this.translate(password, sub);\n\n        for (let match of Array.from(this.dictionary_match(subbed_password, _ranked_dictionaries))) {\n          token = password.slice(match.i, +match.j + 1 || undefined);\n\n          if (token.toLowerCase() === match.matched_word) {\n            continue; // only return the matches that contain an actual substitution\n          }\n\n          var match_sub = {}; // subset of mappings in sub that are in use for this match\n\n          for (let subbed_chr in sub) {\n            const chr = sub[subbed_chr];\n\n            if (token.indexOf(subbed_chr) !== -1) {\n              match_sub[subbed_chr] = chr;\n            }\n          }\n\n          match.l33t = true;\n          match.token = token;\n          match.sub = match_sub;\n\n          match.sub_display = (() => {\n            const result = [];\n\n            for (let k in match_sub) {\n              const v = match_sub[k];\n              result.push(`${k} -> ${v}`);\n            }\n\n            return result;\n          })().join(', ');\n\n          matches.push(match);\n        }\n      }\n\n      return this.sorted(matches.filter(match => // filter single-character l33t matches to reduce noise.\n      // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n      // with low dictionary rank.\n      match.token.length > 1));\n    } // ------------------------------------------------------------------------------\n    // spatial match (qwerty/dvorak/keypad) -----------------------------------------\n    // ------------------------------------------------------------------------------\n\n\n    static spatial_match(password, additionalGraphs) {\n      const _graphs = GRAPHS;\n\n      for (const [name, {\n        layout,\n        slanted\n      }] of Object.entries(additionalGraphs || {})) {\n        if (layout) {\n          GRAPHS[name] = build_graph(layout, slanted);\n        }\n      }\n\n      const matches = [];\n\n      for (let graph_name in _graphs) {\n        const graph = _graphs[graph_name];\n        this.extend(matches, this.spatial_match_helper(password, graph, graph_name));\n      }\n\n      return this.sorted(matches);\n    }\n\n    static spatial_match_helper(password, graph, graph_name) {\n      const matches = [];\n      let i = 0;\n\n      while (i < password.length - 1) {\n        var shifted_count;\n        let j = i + 1;\n        let last_direction = null;\n        let turns = 0;\n\n        if (['qwerty', 'dvorak'].includes(graph_name) && this.SHIFTED_RX.exec(password.charAt(i))) {\n          // initial character is shifted\n          shifted_count = 1;\n        } else {\n          shifted_count = 0;\n        }\n\n        while (true) {\n          const prev_char = password.charAt(j - 1);\n          let found = false;\n          let found_direction = -1;\n          let cur_direction = -1;\n          const adjacents = graph[prev_char] || []; // consider growing pattern by one character if j hasn't gone over the edge.\n\n          if (j < password.length) {\n            const cur_char = password.charAt(j);\n\n            for (let adj of Array.from(adjacents)) {\n              cur_direction += 1;\n\n              if (adj && adj.indexOf(cur_char) !== -1) {\n                found = true;\n                found_direction = cur_direction;\n\n                if (adj.indexOf(cur_char) === 1) {\n                  // index 1 in the adjacency means the key is shifted,\n                  // 0 means unshifted: A vs a, % vs 5, etc.\n                  // for example, 'q' is adjacent to the entry '2@'.\n                  // @ is shifted w/ index 1, 2 is unshifted.\n                  shifted_count += 1;\n                }\n\n                if (last_direction !== found_direction) {\n                  // adding a turn is correct even in the initial case when last_direction is null:\n                  // every spatial pattern starts with a turn.\n                  turns += 1;\n                  last_direction = found_direction;\n                }\n\n                break;\n              }\n            }\n          } // if the current pattern continued, extend j and try to grow again\n\n\n          if (found) {\n            j += 1; // otherwise push the pattern discovered so far, if any...\n          } else {\n            if (j - i > 2) {\n              // don't consider length 1 or 2 chains.\n              matches.push({\n                pattern: 'spatial',\n                i,\n                j: j - 1,\n                token: password.slice(i, j),\n                graph: graph_name,\n                turns,\n                shifted_count\n              });\n            } // ...and then start a new search for the rest of the password.\n\n\n            i = j;\n            break;\n          }\n        }\n      }\n\n      return matches;\n    } //-------------------------------------------------------------------------------\n    // repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------\n    //-------------------------------------------------------------------------------\n\n\n    static repeat_match(password, options) {\n      const matches = [];\n      const greedy = /(.+)\\1+/g;\n      const lazy = /(.+?)\\1+/g;\n      const lazy_anchored = /^(.+?)\\1+$/;\n      let lastIndex = 0;\n\n      while (lastIndex < password.length) {\n        var base_token, match;\n        greedy.lastIndex = lazy.lastIndex = lastIndex;\n        const greedy_match = greedy.exec(password);\n        const lazy_match = lazy.exec(password);\n\n        if (greedy_match == null) {\n          break;\n        }\n\n        if (greedy_match[0].length > lazy_match[0].length) {\n          // greedy beats lazy for 'aabaab'\n          //   greedy: [aabaab, aab]\n          //   lazy:   [aa,     a]\n          match = greedy_match; // greedy's repeated string might itself be repeated, eg.\n          // aabaab in aabaabaabaab.\n          // run an anchored lazy match on greedy's repeated string\n          // to find the shortest repeated string\n\n          base_token = lazy_anchored.exec(match[0])[1];\n        } else {\n          // lazy beats greedy for 'aaaaa'\n          //   greedy: [aaaa,  aa]\n          //   lazy:   [aaaaa, a]\n          match = lazy_match;\n          base_token = match[1];\n        }\n\n        const [i, j] = Array.from([match.index, match.index + match[0].length - 1]); // recursively match and score the base string\n\n        const base_analysis = Scoring.most_guessable_match_sequence(base_token, this.omnimatch(base_token, options));\n        const base_matches = base_analysis.sequence;\n        const base_guesses = base_analysis.guesses;\n        matches.push({\n          pattern: 'repeat',\n          i,\n          j,\n          token: match[0],\n          base_token,\n          base_guesses,\n          base_matches,\n          repeat_count: match[0].length / base_token.length\n        });\n        lastIndex = j + 1;\n      }\n\n      return matches;\n    }\n\n    static sequence_match(password) {\n      // Identifies sequences by looking for repeated differences in unicode codepoint.\n      // this allows skipping, such as 9753, and also matches some extended unicode sequences\n      // such as Greek and Cyrillic alphabets.\n      //\n      // for example, consider the input 'abcdb975zy'\n      //\n      // password: a   b   c   d   b    9   7   5   z   y\n      // index:    0   1   2   3   4    5   6   7   8   9\n      // delta:      1   1   1  -2  -41  -2  -2  69   1\n      //\n      // expected result:\n      // [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n      if (password.length === 1) {\n        return [];\n      }\n\n      const update = (i, j, delta) => {\n        if (j - i > 1 || Math.abs(delta) === 1) {\n          let middle;\n\n          if (0 < (middle = Math.abs(delta)) && middle <= this.MAX_DELTA) {\n            let sequence_name, sequence_space;\n            const token = password.slice(i, +j + 1 || undefined);\n\n            if (/^[a-z]+$/.test(token)) {\n              sequence_name = 'lower';\n              sequence_space = 26;\n            } else if (/^[A-Z]+$/.test(token)) {\n              sequence_name = 'upper';\n              sequence_space = 26;\n            } else if (/^\\d+$/.test(token)) {\n              sequence_name = 'digits';\n              sequence_space = 10;\n            } else {\n              // conservatively stick with roman alphabet size.\n              // (this could be improved)\n              sequence_name = 'unicode';\n              sequence_space = 26;\n            }\n\n            return result.push({\n              pattern: 'sequence',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || undefined),\n              sequence_name,\n              sequence_space,\n              ascending: delta > 0\n            });\n          }\n        }\n      };\n\n      var result = [];\n      let i = 0;\n      let last_delta = null;\n\n      for (let k = 1, end = password.length, asc = 1 <= end; asc ? k < end : k > end; asc ? k++ : k--) {\n        const delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n\n        if (last_delta == null) {\n          last_delta = delta;\n        }\n\n        if (delta === last_delta) {\n          continue;\n        }\n\n        const j = k - 1;\n        update(i, j, last_delta);\n        i = j;\n        last_delta = delta;\n      }\n\n      update(i, password.length - 1, last_delta);\n      return result;\n    } //-------------------------------------------------------------------------------\n    // regex matching ---------------------------------------------------------------\n    //-------------------------------------------------------------------------------\n\n\n    static regex_match(password) {\n      const _regexen = REGEXEN;\n      const matches = [];\n\n      for (name in _regexen) {\n        var rx_match;\n        const regex = _regexen[name];\n        regex.lastIndex = 0; // keeps regex_match stateless\n\n        while (rx_match = regex.exec(password)) {\n          const token = rx_match[0];\n          matches.push({\n            pattern: 'regex',\n            token,\n            i: rx_match.index,\n            j: rx_match.index + rx_match[0].length - 1,\n            regex_name: name,\n            regex_match: rx_match\n          });\n        }\n      }\n\n      return this.sorted(matches);\n    } //-------------------------------------------------------------------------------\n    // date matching ----------------------------------------------------------------\n    //-------------------------------------------------------------------------------\n\n\n    static date_match(password) {\n      // a \"date\" is recognized as:\n      //   any 3-tuple that starts or ends with a 2- or 4-digit year,\n      //   with 2 or 0 separator chars (1.1.91 or 1191),\n      //   maybe zero-padded (01-01-91 vs 1-1-91),\n      //   a month between 1 and 12,\n      //   a day between 1 and 31.\n      //\n      // note: this isn't true date parsing in that \"feb 31st\" is allowed,\n      // this doesn't check for leap years, etc.\n      //\n      // recipe:\n      // start with regex to find maybe-dates, then attempt to map the integers\n      // onto month-day-year to filter the maybe-dates into dates.\n      // finally, remove matches that are substrings of other matches to reduce noise.\n      //\n      // note: instead of using a lazy or greedy regex to find many dates over the full string,\n      // this uses a ^...$ regex against every substring of the password -- less performant but leads\n      // to every possible date match.\n      let dmy, i, j, token;\n      let asc, end;\n      let asc2, end2;\n      const matches = [];\n      const maybe_date_no_separator = /^\\d{4,8}$/;\n      const maybe_date_with_separator = new RegExp(`\\\n^\\\n(\\\\d{1,4})\\\n([\\\\s/\\\\\\\\_.-])\\\n(\\\\d{1,2})\\\n\\\\2\\\n(\\\\d{1,4})\\\n$\\\n`); // dates without separators are between length 4 '1191' and 8 '11111991'\n\n      for (i = 0, end = password.length - 4, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n        var asc1, end1, start;\n\n        for (start = i + 3, j = start, end1 = i + 7, asc1 = start <= end1; asc1 ? j <= end1 : j >= end1; asc1 ? j++ : j--) {\n          if (j >= password.length) {\n            break;\n          }\n\n          token = password.slice(i, +j + 1 || undefined);\n\n          if (!maybe_date_no_separator.exec(token)) {\n            continue;\n          }\n\n          const candidates = [];\n\n          for (let [k, l] of Array.from(DATE_SPLITS[token.length])) {\n            dmy = this.map_ints_to_dmy([parseInt(token.slice(0, k)), parseInt(token.slice(k, l)), parseInt(token.slice(l))]);\n\n            if (dmy != null) {\n              candidates.push(dmy);\n            }\n          }\n\n          if (!(candidates.length > 0)) {\n            continue;\n          } // at this point: different possible dmy mappings for the same i,j substring.\n          // match the candidate date that likely takes the fewest guesses: a year closest to 2000.\n          // (scoring.REFERENCE_YEAR).\n          //\n          // ie, considering '111504', prefer 11-15-04 to 1-1-1504\n          // (interpreting '04' as 2004)\n\n\n          let best_candidate = candidates[0];\n\n          const metric = candidate => Math.abs(candidate.year - Scoring.REFERENCE_YEAR);\n\n          let min_distance = metric(candidates[0]);\n\n          for (let candidate of Array.from(candidates.slice(1))) {\n            const distance = metric(candidate);\n\n            if (distance < min_distance) {\n              [best_candidate, min_distance] = Array.from([candidate, distance]);\n            }\n          }\n\n          matches.push({\n            pattern: 'date',\n            token,\n            i,\n            j,\n            separator: '',\n            year: best_candidate.year,\n            month: best_candidate.month,\n            day: best_candidate.day\n          });\n        }\n      } // dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n\n\n      for (i = 0, end2 = password.length - 6, asc2 = 0 <= end2; asc2 ? i <= end2 : i >= end2; asc2 ? i++ : i--) {\n        var asc3, end3, start1;\n\n        for (start1 = i + 5, j = start1, end3 = i + 9, asc3 = start1 <= end3; asc3 ? j <= end3 : j >= end3; asc3 ? j++ : j--) {\n          if (j >= password.length) {\n            break;\n          }\n\n          token = password.slice(i, +j + 1 || undefined);\n          const rx_match = maybe_date_with_separator.exec(token);\n\n          if (rx_match == null) {\n            continue;\n          }\n\n          dmy = this.map_ints_to_dmy([parseInt(rx_match[1]), parseInt(rx_match[3]), parseInt(rx_match[4])]);\n\n          if (dmy == null) {\n            continue;\n          }\n\n          matches.push({\n            pattern: 'date',\n            token,\n            i,\n            j,\n            separator: rx_match[2],\n            year: dmy.year,\n            month: dmy.month,\n            day: dmy.day\n          });\n        }\n      } // matches now contains all valid date strings in a way that is tricky to capture\n      // with regexes only. while thorough, it will contain some unintuitive noise:\n      //\n      // '2015_06_04', in addition to matching 2015_06_04, will also contain\n      // 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n      //\n      // to reduce noise, remove date matches that are strict substrings of others\n\n\n      return this.sorted(matches.filter(function (match) {\n        let is_submatch = false;\n\n        for (let other_match of Array.from(matches)) {\n          if (match === other_match) {\n            continue;\n          }\n\n          if (other_match.i <= match.i && other_match.j >= match.j) {\n            is_submatch = true;\n            break;\n          }\n        }\n\n        return !is_submatch;\n      }));\n    }\n\n    static map_ints_to_dmy(ints) {\n      // given a 3-tuple, discard if:\n      //   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n      //   middle int is zero\n      //   any int is over the max allowable year\n      //   any int is over two digits but under the min allowable year\n      //   2 ints are over 31, the max allowable day\n      //   2 ints are zero\n      //   all ints are over 12, the max allowable month\n      let dm, rest, y;\n\n      if (ints[1] > 31 || ints[1] <= 0) {\n        return;\n      }\n\n      let over_12 = 0;\n      let over_31 = 0;\n      let under_1 = 0;\n\n      for (let int of Array.from(ints)) {\n        if (99 < int && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n          return;\n        }\n\n        if (int > 31) {\n          over_31 += 1;\n        }\n\n        if (int > 12) {\n          over_12 += 1;\n        }\n\n        if (int <= 0) {\n          under_1 += 1;\n        }\n      }\n\n      if (over_31 >= 2 || over_12 === 3 || under_1 >= 2) {\n        return;\n      } // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n\n\n      const possible_year_splits = [[ints[2], ints.slice(0, 2)], [ints[0], ints.slice(1, 3)] // year first\n      ];\n\n      for ([y, rest] of Array.from(possible_year_splits)) {\n        if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n          dm = this.map_ints_to_dm(rest);\n\n          if (dm != null) {\n            return {\n              year: y,\n              month: dm.month,\n              day: dm.day\n            };\n          } else {\n            // for a candidate that includes a four-digit year,\n            // when the remaining ints don't match to a day and month,\n            // it is not a date.\n            return;\n          }\n        }\n      } // given no four-digit year, two digit years are the most flexible int to match, so\n      // try to parse a day-month out of ints[0..1] or ints[1..0]\n\n\n      for ([y, rest] of Array.from(possible_year_splits)) {\n        dm = this.map_ints_to_dm(rest);\n\n        if (dm != null) {\n          y = this.two_to_four_digit_year(y);\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        }\n      }\n    }\n\n    static map_ints_to_dm(ints) {\n      for (let [d, m] of [ints, ints.slice().reverse()]) {\n        if (1 <= d && d <= 31 && 1 <= m && m <= 12) {\n          return {\n            day: d,\n            month: m\n          };\n        }\n      }\n    }\n\n    static two_to_four_digit_year(year) {\n      if (year > 99) {\n        return year;\n      } else if (year > 50) {\n        // 87 -> 1987\n        return year + 1900;\n      } else {\n        // 15 -> 2015\n        return year + 2000;\n      }\n    }\n\n  }\n\n  Matching.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/; //# sourceMappingURL=matching.js.map\n\n  return Matching;\n})();","map":null,"metadata":{},"sourceType":"module"}