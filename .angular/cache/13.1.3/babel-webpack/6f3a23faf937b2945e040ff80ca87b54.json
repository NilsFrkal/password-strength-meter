{"ast":null,"code":"import { Scoring } from './scoring';\nexport function translate(v, options) {\n  if (options.i18n[options.language] && options.i18n[options.language][v]) {\n    return options.i18n[options.language][v];\n  }\n\n  if (options.i18n[\"en\"] && options.i18n[\"en\"][v]) {\n    return options.i18n[\"en\"][v];\n  }\n\n  console.log(\"not found\", v);\n  return v;\n}\nexport class Feedback {\n  static get_feedback(score, sequence, options) {\n    // starting feedback\n    if (sequence.length === 0) {\n      return this.default_feedback;\n    } // no feedback if score is good or great.\n\n\n    if (score > 2) {\n      return {\n        warning: '',\n        suggestions: []\n      };\n    } // tie feedback to the longest match for longer sequences\n\n\n    let longest_match = sequence[0];\n\n    for (let match of Array.from(sequence.slice(1))) {\n      if (match.token.length > longest_match.token.length) {\n        longest_match = match;\n      }\n    }\n\n    let feedback = this.get_match_feedback(longest_match, sequence.length === 1, options);\n    const extra_feedback = translate('ADD_MORE_WORDS', options);\n\n    if (feedback != null) {\n      feedback.suggestions.unshift(extra_feedback);\n\n      if (feedback.warning == null) {\n        feedback.warning = '';\n      }\n    } else {\n      feedback = {\n        warning: '',\n        suggestions: [extra_feedback]\n      };\n    }\n\n    return feedback;\n  }\n\n  static get_match_feedback(match, is_sole_match, options) {\n    let result = {\n      warning: \"\",\n      suggestions: []\n    };\n\n    switch (match.pattern) {\n      case 'dictionary':\n        result = this.get_dictionary_match_feedback(match, is_sole_match, options);\n\n      case 'spatial':\n        var warning = match.turns === 1 ? 'NO_STRAIGHT_ROWS' : 'NO_SHORT_PATTERNS';\n        result.warning = warning;\n        result.suggestions = ['USE_LONGER_PATTERN'];\n        break;\n\n      case 'repeat':\n        warning = match.base_token.length === 1 ? 'NO_REPEATS' : 'NO_REPEATING_REPEATS';\n        result.warning = warning;\n        result.suggestions = ['AVOID_REPEATS'];\n        break;\n\n      case 'sequence':\n        result.warning = \"NO_SEQUENCES\";\n        result.suggestions = ['AVOID_SEQUENCES'];\n        break;\n\n      case 'regex':\n        if (match.regex_name === 'recent_year') {\n          result.warning = \"NO_RECENT_YEARS\";\n          result.suggestions = ['AVOID_RECENT_YEARS', 'AVOID_YEARS_ASSOCIATED_WITH_YOU'];\n        }\n\n        break;\n\n      case 'date':\n        result.warning = \"NO_DATES\", result.suggestions = ['AVOID_DATES'];\n        break;\n    }\n\n    return {\n      warning: translate(result.warning, options),\n      suggestions: result.suggestions.map(s => translate(s, options))\n    };\n  }\n\n  static get_dictionary_match_feedback(match, is_sole_match, options) {\n    const warning = (() => {\n      if (match.dictionary_name === 'passwords') {\n        if (is_sole_match && !match.l33t && !match.reversed) {\n          if (match.rank <= 10) {\n            return 'TOP_10_PASSWORD';\n          } else if (match.rank <= 100) {\n            return 'TOP_100_PASSWORD';\n          } else {\n            return 'VERY_COMMON_PASSWORD';\n          }\n        } else if (match.guesses_log10 <= 4) {\n          return 'NO_SIMILAR_PASSWORDS';\n        }\n      } else if (match.dictionary_name === 'english_wikipedia') {\n        if (is_sole_match) {\n          return 'NOT_JUST_ONE_WORD';\n        }\n      } else if (['surnames', 'male_names', 'female_names'].includes(match.dictionary_name)) {\n        if (is_sole_match) {\n          return 'NOT_JUST_NAMES_AND_SURNAMES';\n        } else {\n          return 'NO_COMMON_NAMES';\n        }\n      } else {\n        return '';\n      }\n    })();\n\n    const suggestions = [];\n    const word = match.token;\n\n    if (word.match(Scoring.START_UPPER)) {\n      suggestions.push(\"CAPITALIZATION_DOESNT_MATTER\");\n    } else if (word.match(Scoring.ALL_UPPER) && word.toLowerCase() !== word) {\n      suggestions.push(\"ALL_UPPERCASE\");\n    }\n\n    if (match.reversed && match.token.length >= 4) {\n      suggestions.push(\"NO_REVERSED_WORDS\");\n    }\n\n    if (match.l33t) {\n      suggestions.push(\"NO_SUBSTITUTIONS\");\n    }\n\n    const result = {\n      warning,\n      suggestions\n    };\n    return result;\n  }\n\n} //# sourceMappingURL=feedback.js.map","map":null,"metadata":{},"sourceType":"module"}