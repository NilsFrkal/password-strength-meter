{"ast":null,"code":"/**\r\n * returns the six adjacent coordinates on a standard keyboard, where each row is slanted to the\r\n * right from the last. adjacencies are clockwise, starting with key to the left, then two keys\r\n * above, then right key, then two keys below. (that is, only near-diagonal keys are adjacent,\r\n * so g's coordinate is adjacent to those of t,y,b,v, but not those of r,u,n,c.)\r\n */\nexport function get_slanted_adjacent_coords(x, y) {\n  return [[x - 1, y], [x, y - 1], [x + 1, y - 1], [x + 1, y], [x, y + 1], [x - 1, y + 1]];\n}\n/**\r\n * returns the nine clockwise adjacent coordinates on a keypad, where each row is vert aligned.\r\n */\n\nexport function get_aligned_adjacent_coords(x, y) {\n  return [[x - 1, y], [x - 1, y - 1], [x, y - 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1], [x, y + 1], [x - 1, y + 1]];\n}\n/**\r\n * builds an adjacency graph as a dictionary: {character: [adjacent_characters]}.\r\n * adjacent characters occur in a clockwise order.\r\n * for example:\r\n *   on qwerty layout, 'g' maps to ['fF', 'tT', 'yY', 'hH', 'bB', 'vV']\r\n *   on keypad layout, '7' maps to [None, None, None, '=', '8', '5', '4', None]\r\n */\n\nexport function build_graph(layout_str, slanted) {\n  layout_str = layout_str.replace(/^\\n|\\n$/g, \"\"); // replace line breaks at start and end\n\n  const position_table = []; // maps from tuple (x,y) -> characters at that position.\n\n  const tokens = layout_str.split(/\\n| /g).filter(t => t !== \"\").map(t => t.replace(/\\n/g, \"\"));\n  const token_size = tokens[0].length;\n  const x_unit = token_size + 1; // x position unit len is token len plus 1 for the following whitespace.\n\n  const adjacency_func = slanted ? get_slanted_adjacent_coords : get_aligned_adjacent_coords;\n\n  for (const token of tokens) {\n    if (token.length != token_size) {\n      throw new Error('token len mismatch:\\n ' + layout_str);\n    }\n  }\n\n  const lines = layout_str.split('\\n');\n\n  for (const y of lines.keys()) {\n    const line = lines[y]; // the way I illustrated keys above, each qwerty row is indented one space in from the last\n\n    const slant = slanted ? y - 1 : 0;\n\n    for (const token of line.split(\" \").filter(t => t !== \"\")) {\n      const x = Math.floor((line.indexOf(token) - slant - (slanted ? 1 : 0)) / x_unit);\n      const remainder = (line.indexOf(token) - slant - (slanted ? 1 : 0)) % x_unit;\n\n      if (remainder) {\n        throw new Error(`unexpected x offset ${remainder} for ${token} in:\\n${layout_str}`);\n      }\n\n      if (!position_table[x]) {\n        position_table[x] = [];\n      }\n\n      position_table[x][y] = token;\n    }\n  }\n\n  const adjacency_graph = {};\n\n  for (const line of position_table) {\n    for (const chars of line) {\n      for (const char of chars || []) {\n        adjacency_graph[char] = [];\n\n        for (const [x2, y2] of adjacency_func(position_table.indexOf(line), line.indexOf(chars))) {\n          /* position in the list indicates direction\r\n          for qwerty, 0 is left, 1 is top, 2 is top right, ...)\r\n          for edge chars like 1 or m, insert None as a placeholder when needed\r\n          so that each character in the graph has a same - length adjacency list. */\n          adjacency_graph[char].push(position_table[x2] && position_table[x2][y2] ? position_table[x2][y2] : null);\n        }\n      }\n    }\n  }\n\n  return adjacency_graph;\n} //# sourceMappingURL=generate_adjacency_graph.js.map","map":null,"metadata":{},"sourceType":"module"}